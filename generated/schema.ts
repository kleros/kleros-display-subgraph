// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class ArbitrableHistory extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ArbitrableHistory entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ArbitrableHistory must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ArbitrableHistory", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): ArbitrableHistory | null {
    return changetype<ArbitrableHistory | null>(
      store.get_in_block("ArbitrableHistory", id.toHexString())
    );
  }

  static load(id: Bytes): ArbitrableHistory | null {
    return changetype<ArbitrableHistory | null>(
      store.get("ArbitrableHistory", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get metaEvidence(): string {
    let value = this.get("metaEvidence");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set metaEvidence(value: string) {
    this.set("metaEvidence", Value.fromString(value));
  }

  get disputes(): DisputeLoader {
    return new DisputeLoader(
      "ArbitrableHistory",
      this.get("id")!.toString(),
      "disputes"
    );
  }
}

export class Dispute extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Dispute entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Dispute must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Dispute", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Dispute | null {
    return changetype<Dispute | null>(store.get_in_block("Dispute", id));
  }

  static load(id: string): Dispute | null {
    return changetype<Dispute | null>(store.get("Dispute", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get disputeIDNumber(): BigInt {
    let value = this.get("disputeIDNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set disputeIDNumber(value: BigInt) {
    this.set("disputeIDNumber", Value.fromBigInt(value));
  }

  get arbitrated(): Bytes {
    let value = this.get("arbitrated");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set arbitrated(value: Bytes) {
    this.set("arbitrated", Value.fromBytes(value));
  }

  get metaEvidenceId(): BigInt {
    let value = this.get("metaEvidenceId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set metaEvidenceId(value: BigInt) {
    this.set("metaEvidenceId", Value.fromBigInt(value));
  }

  get arbitrableHistory(): Bytes | null {
    let value = this.get("arbitrableHistory");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set arbitrableHistory(value: Bytes | null) {
    if (!value) {
      this.unset("arbitrableHistory");
    } else {
      this.set("arbitrableHistory", Value.fromBytes(<Bytes>value));
    }
  }

  get ruling(): BigInt {
    let value = this.get("ruling");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set ruling(value: BigInt) {
    this.set("ruling", Value.fromBigInt(value));
  }

  get ruled(): boolean {
    let value = this.get("ruled");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set ruled(value: boolean) {
    this.set("ruled", Value.fromBoolean(value));
  }

  get period(): string {
    let value = this.get("period");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set period(value: string) {
    this.set("period", Value.fromString(value));
  }

  get createdAtBlock(): BigInt {
    let value = this.get("createdAtBlock");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdAtBlock(value: BigInt) {
    this.set("createdAtBlock", Value.fromBigInt(value));
  }

  get court(): string {
    let value = this.get("court");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set court(value: string) {
    this.set("court", Value.fromString(value));
  }

  get periodDeadline(): BigInt {
    let value = this.get("periodDeadline");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set periodDeadline(value: BigInt) {
    this.set("periodDeadline", Value.fromBigInt(value));
  }

  get periodNotificationIndex(): BigInt {
    let value = this.get("periodNotificationIndex");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set periodNotificationIndex(value: BigInt) {
    this.set("periodNotificationIndex", Value.fromBigInt(value));
  }

  get lastPeriodChangeTs(): BigInt {
    let value = this.get("lastPeriodChangeTs");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lastPeriodChangeTs(value: BigInt) {
    this.set("lastPeriodChangeTs", Value.fromBigInt(value));
  }

  get lastPeriodChangeBlock(): BigInt {
    let value = this.get("lastPeriodChangeBlock");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lastPeriodChangeBlock(value: BigInt) {
    this.set("lastPeriodChangeBlock", Value.fromBigInt(value));
  }

  get nbChoices(): BigInt {
    let value = this.get("nbChoices");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set nbChoices(value: BigInt) {
    this.set("nbChoices", Value.fromBigInt(value));
  }

  get nbRounds(): BigInt {
    let value = this.get("nbRounds");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set nbRounds(value: BigInt) {
    this.set("nbRounds", Value.fromBigInt(value));
  }

  get currentRound(): Bytes {
    let value = this.get("currentRound");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set currentRound(value: Bytes) {
    this.set("currentRound", Value.fromBytes(value));
  }

  get rounds(): RoundLoader {
    return new RoundLoader("Dispute", this.get("id")!.toString(), "rounds");
  }

  get evidenceGroup(): EvidenceGroupLoader {
    return new EvidenceGroupLoader(
      "Dispute",
      this.get("id")!.toString(),
      "evidenceGroup"
    );
  }
}

export class Round extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Round entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Round must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Round", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Round | null {
    return changetype<Round | null>(
      store.get_in_block("Round", id.toHexString())
    );
  }

  static load(id: Bytes): Round | null {
    return changetype<Round | null>(store.get("Round", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get round(): BigInt {
    let value = this.get("round");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set round(value: BigInt) {
    this.set("round", Value.fromBigInt(value));
  }

  get isCurrentRound(): boolean {
    let value = this.get("isCurrentRound");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isCurrentRound(value: boolean) {
    this.set("isCurrentRound", Value.fromBoolean(value));
  }

  get dispute(): string {
    let value = this.get("dispute");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set dispute(value: string) {
    this.set("dispute", Value.fromString(value));
  }

  get jurors(): Array<Bytes> {
    let value = this.get("jurors");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytesArray();
    }
  }

  set jurors(value: Array<Bytes>) {
    this.set("jurors", Value.fromBytesArray(value));
  }
}

export class UserDisputeInfo extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserDisputeInfo entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserDisputeInfo must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserDisputeInfo", id.toString(), this);
    }
  }

  static loadInBlock(id: string): UserDisputeInfo | null {
    return changetype<UserDisputeInfo | null>(
      store.get_in_block("UserDisputeInfo", id)
    );
  }

  static load(id: string): UserDisputeInfo | null {
    return changetype<UserDisputeInfo | null>(store.get("UserDisputeInfo", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get dispute(): string {
    let value = this.get("dispute");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set dispute(value: string) {
    this.set("dispute", Value.fromString(value));
  }

  get juror(): string {
    let value = this.get("juror");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set juror(value: string) {
    this.set("juror", Value.fromString(value));
  }
}

export class UserRoundInfo extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserRoundInfo entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserRoundInfo must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UserRoundInfo", id.toString(), this);
    }
  }

  static loadInBlock(id: string): UserRoundInfo | null {
    return changetype<UserRoundInfo | null>(
      store.get_in_block("UserRoundInfo", id)
    );
  }

  static load(id: string): UserRoundInfo | null {
    return changetype<UserRoundInfo | null>(store.get("UserRoundInfo", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get dispute(): string {
    let value = this.get("dispute");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set dispute(value: string) {
    this.set("dispute", Value.fromString(value));
  }

  get drawNotificationIndex(): BigInt {
    let value = this.get("drawNotificationIndex");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set drawNotificationIndex(value: BigInt) {
    this.set("drawNotificationIndex", Value.fromBigInt(value));
  }

  get juror(): string {
    let value = this.get("juror");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set juror(value: string) {
    this.set("juror", Value.fromString(value));
  }

  get round(): Bytes {
    let value = this.get("round");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set round(value: Bytes) {
    this.set("round", Value.fromBytes(value));
  }
}

export class Counter extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Counter entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Counter must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Counter", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Counter | null {
    return changetype<Counter | null>(store.get_in_block("Counter", id));
  }

  static load(id: string): Counter | null {
    return changetype<Counter | null>(store.get("Counter", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get counter(): BigInt {
    let value = this.get("counter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set counter(value: BigInt) {
    this.set("counter", Value.fromBigInt(value));
  }
}

export class Court extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Court entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Court must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Court", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Court | null {
    return changetype<Court | null>(store.get_in_block("Court", id));
  }

  static load(id: string): Court | null {
    return changetype<Court | null>(store.get("Court", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timesPerPeriod(): Array<BigInt> | null {
    let value = this.get("timesPerPeriod");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigIntArray();
    }
  }

  set timesPerPeriod(value: Array<BigInt> | null) {
    if (!value) {
      this.unset("timesPerPeriod");
    } else {
      this.set("timesPerPeriod", Value.fromBigIntArray(<Array<BigInt>>value));
    }
  }

  get hiddenVotes(): boolean {
    let value = this.get("hiddenVotes");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set hiddenVotes(value: boolean) {
    this.set("hiddenVotes", Value.fromBoolean(value));
  }

  get policy(): string | null {
    let value = this.get("policy");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set policy(value: string | null) {
    if (!value) {
      this.unset("policy");
    } else {
      this.set("policy", Value.fromString(<string>value));
    }
  }

  get name(): string | null {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set name(value: string | null) {
    if (!value) {
      this.unset("name");
    } else {
      this.set("name", Value.fromString(<string>value));
    }
  }

  get description(): string | null {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set description(value: string | null) {
    if (!value) {
      this.unset("description");
    } else {
      this.set("description", Value.fromString(<string>value));
    }
  }

  get summary(): string | null {
    let value = this.get("summary");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set summary(value: string | null) {
    if (!value) {
      this.unset("summary");
    } else {
      this.set("summary", Value.fromString(<string>value));
    }
  }

  get requiredSkills(): string | null {
    let value = this.get("requiredSkills");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set requiredSkills(value: string | null) {
    if (!value) {
      this.unset("requiredSkills");
    } else {
      this.set("requiredSkills", Value.fromString(<string>value));
    }
  }
}

export class Draw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Draw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Draw must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Draw", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Draw | null {
    return changetype<Draw | null>(store.get_in_block("Draw", id));
  }

  static load(id: string): Draw | null {
    return changetype<Draw | null>(store.get("Draw", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get appeal(): BigInt {
    let value = this.get("appeal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set appeal(value: BigInt) {
    this.set("appeal", Value.fromBigInt(value));
  }

  get disputeID(): BigInt {
    let value = this.get("disputeID");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set disputeID(value: BigInt) {
    this.set("disputeID", Value.fromBigInt(value));
  }

  get voteID(): BigInt {
    let value = this.get("voteID");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set voteID(value: BigInt) {
    this.set("voteID", Value.fromBigInt(value));
  }
}

export class TokenAndETHShift extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TokenAndETHShift entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TokenAndETHShift must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TokenAndETHShift", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TokenAndETHShift | null {
    return changetype<TokenAndETHShift | null>(
      store.get_in_block("TokenAndETHShift", id)
    );
  }

  static load(id: string): TokenAndETHShift | null {
    return changetype<TokenAndETHShift | null>(
      store.get("TokenAndETHShift", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get ETHAmount(): BigInt {
    let value = this.get("ETHAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set ETHAmount(value: BigInt) {
    this.set("ETHAmount", Value.fromBigInt(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get disputeID(): BigInt {
    let value = this.get("disputeID");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set disputeID(value: BigInt) {
    this.set("disputeID", Value.fromBigInt(value));
  }

  get tokenAmount(): BigInt {
    let value = this.get("tokenAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set tokenAmount(value: BigInt) {
    this.set("tokenAmount", Value.fromBigInt(value));
  }
}

export class EvidenceGroup extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save EvidenceGroup entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type EvidenceGroup must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EvidenceGroup", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): EvidenceGroup | null {
    return changetype<EvidenceGroup | null>(
      store.get_in_block("EvidenceGroup", id.toHexString())
    );
  }

  static load(id: Bytes): EvidenceGroup | null {
    return changetype<EvidenceGroup | null>(
      store.get("EvidenceGroup", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get dispute(): string | null {
    let value = this.get("dispute");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set dispute(value: string | null) {
    if (!value) {
      this.unset("dispute");
    } else {
      this.set("dispute", Value.fromString(<string>value));
    }
  }

  get length(): BigInt {
    let value = this.get("length");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set length(value: BigInt) {
    this.set("length", Value.fromBigInt(value));
  }

  get evidence(): EvidenceLoader {
    return new EvidenceLoader(
      "EvidenceGroup",
      this.get("id")!.toString(),
      "evidence"
    );
  }
}

export class Evidence extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Evidence entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Evidence must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Evidence", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Evidence | null {
    return changetype<Evidence | null>(
      store.get_in_block("Evidence", id.toHexString())
    );
  }

  static load(id: Bytes): Evidence | null {
    return changetype<Evidence | null>(store.get("Evidence", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get group(): Bytes {
    let value = this.get("group");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set group(value: Bytes) {
    this.set("group", Value.fromBytes(value));
  }

  get creationTime(): BigInt {
    let value = this.get("creationTime");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set creationTime(value: BigInt) {
    this.set("creationTime", Value.fromBigInt(value));
  }

  get URI(): string {
    let value = this.get("URI");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set URI(value: string) {
    this.set("URI", Value.fromString(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class StakeSet extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StakeSet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakeSet must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakeSet", id.toString(), this);
    }
  }

  static loadInBlock(id: string): StakeSet | null {
    return changetype<StakeSet | null>(store.get_in_block("StakeSet", id));
  }

  static load(id: string): StakeSet | null {
    return changetype<StakeSet | null>(store.get("StakeSet", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get subcourtID(): BigInt {
    let value = this.get("subcourtID");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set subcourtID(value: BigInt) {
    this.set("subcourtID", Value.fromBigInt(value));
  }

  get stake(): BigInt {
    let value = this.get("stake");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set stake(value: BigInt) {
    this.set("stake", Value.fromBigInt(value));
  }

  get newTotalStake(): BigInt {
    let value = this.get("newTotalStake");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set newTotalStake(value: BigInt) {
    this.set("newTotalStake", Value.fromBigInt(value));
  }

  get blocknumber(): BigInt {
    let value = this.get("blocknumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blocknumber(value: BigInt) {
    this.set("blocknumber", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get logIndex(): BigInt {
    let value = this.get("logIndex");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set logIndex(value: BigInt) {
    this.set("logIndex", Value.fromBigInt(value));
  }
}

export class DisputeLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Dispute[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Dispute[]>(value);
  }
}

export class RoundLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Round[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Round[]>(value);
  }
}

export class EvidenceGroupLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): EvidenceGroup[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<EvidenceGroup[]>(value);
  }
}

export class EvidenceLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Evidence[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Evidence[]>(value);
  }
}
